% Visualize 3D point clouds generated by different reconstruction models
% and compare them against a reference FARO point cloud. It calculates
% Chamfer Distance (CD) and optionally saves scaled point clouds using FARO
% scale, visualizations, and videos.

close all;
path('utility', path);

% Define directories
referenceDir = '/Users/tim/Downloads/SparseView_Reconstruction/faro/crop';
resutlDir = '/Users/tim/Downloads/SparseView_Reconstruction/result/interpolation-5000';

% referenceDir = '/Users/tim/Downloads/SparseView_Reconstruction/validation/interpolation_5000/lpy_tree';
% resutlDir = '/Users/tim/Downloads/SparseView_Reconstruction/validation/interpolation_5000';

% referenceDir = '/Users/tim/Downloads/SparseView_Reconstruction/how_many_views/raw';
% resutlDir = '/Users/tim/Downloads/SparseView_Reconstruction/how_many_views';

pointDir = fullfile(resutlDir, "points");
videoDir = fullfile(resutlDir, "matlab");
scaledPointDir = fullfile(resutlDir, "scaled_points");
normalizedPointDir = fullfile(resutlDir, "normalized_points");

if ~exist(videoDir, 'dir')
    mkdir(videoDir);
end

if ~exist(scaledPointDir, 'dir')
    mkdir(scaledPointDir);
end

if ~exist(normalizedPointDir, 'dir')
    mkdir(normalizedPointDir);
end

% Get all subfolders
subFolders = dir(pointDir);
subFolders = subFolders([subFolders.isdir]); 
subFolders = subFolders(~ismember({subFolders.name}, {'.', '..', 'AppleQSM'}));

% targetFolders = {'main_rgbd_point_sum_lora', 'main_rgbd_point_sum_lora_Scale-0.8'};
% subFolders = subFolders(ismember({subFolders.name}, targetFolders));

% Get .ply files
firstSubFolder = fullfile(pointDir, subFolders(1).name);
plyFiles = dir(fullfile(firstSubFolder, '*.ply'));

% Fixed spacing for visualization
spacing = 1;
% Colormap for point clouds
colors = lines(length(subFolders) + 1);

% Initialize table data
cdTable = cell(length(plyFiles) + 1, length(subFolders) + 2);
cdTable(1, :) = [{'Tree'}, subFolders.name, {'FARO'}]; % Table headers
% Initialize normalization metadata
metaTable = cell(length(plyFiles) + 1, 3);
metaTable(1, :) = {'Tree Name', 'FARO Centroid', 'Max Distance from Centroid'};

% Define options
SAVE_SCALED = true;
FIG = false;
SCREENSHOT = false;
VIDEO = false;
cd_mode = 'quick';  % deterministic

csvFilePath = fullfile(videoDir, 'Chamfer_Distance_Table_pdist2.csv');
metaFilePath = fullfile(videoDir, 'Normalization_Metadata.csv');

% Loop through each .ply file
for fileIdx = 1:length(plyFiles)
    plyFileName = plyFiles(fileIdx).name;
    [~, name, ~] = fileparts(plyFileName);
    
    % Store tree name
    cdTable{fileIdx + 1, 1} = name;
    metaTable{fileIdx + 1, 1} = name;
    
    % Create figure
    fig = figure;
    hold on;
    title(sprintf('Visualizing %s', plyFileName), 'Color', 'w');

    % Load FARO point cloud
    faroFilePath = fullfile(referenceDir, plyFileName);
    if exist(faroFilePath, 'file')
        faroPtCloud = pcread(faroFilePath);
        targetNumPoints = 40960;
        if faroPtCloud.Count > targetNumPoints
            faroPtCloud = pcdownsample(faroPtCloud, 'random', targetNumPoints / faroPtCloud.Count);
        end
        faroPtLocation = faroPtCloud.Location;
        faroCentroid = mean(faroPtLocation, 1);
        faroMaxDist = max(vecnorm(faroPtLocation - faroCentroid, 2, 2));

        % Store data in the table
        metaTable{fileIdx + 1, 2} = faroCentroid;  % Store as a 1x3 vector
        metaTable{fileIdx + 1, 3} = faroMaxDist;   % Store max distance

        faroNormalizedLocations = (faroPtLocation - faroCentroid) / faroMaxDist;
        faroColor = colors(1, :);
        faroColoredPtCloud = pointCloud(faroNormalizedLocations, 'Color', repmat(faroColor, size(faroNormalizedLocations, 1), 1));

        % Save normalizd FARO points
        ptFolder = fullfile(normalizedPointDir, 'faro');
        if ~exist(ptFolder, "dir")
            mkdir(ptFolder)
        end
        % ptFilePath = fullfile(ptFolder, plyFileName);
        % pcwrite(faroColoredPtCloud, ptFilePath);

        pcshow(faroColoredPtCloud, 'MarkerSize', 10);
        legendInfo{1} = 'FARO';
    else
        warning('FARO point cloud file %s not found.', faroFilePath);
        faroNormalizedLocations = [];
    end
    
    % Loop through each subfolder
    for i = 1:length(subFolders)
        plyFilePath = fullfile(pointDir, subFolders(i).name, plyFileName);
        ptCloud = pcread(plyFilePath);
        ptCloudLocation = ptCloud.Location;
        
        % Negate Z-axis if necessary
        % ptCloudLocation(:, 3) = -ptCloudLocation(:, 3);
        
        % Compute scale factor and rescale to match FARO global scale
        ptCentroid = mean(ptCloudLocation, 1);
        ptMaxDist = max(vecnorm(ptCloudLocation - ptCentroid, 2, 2));
        scaleFactor = faroMaxDist / ptMaxDist;  % Critical: Fixes scale drift
        ptCloudLocation = ptCloudLocation * scaleFactor;

        % Recompute stats after rescaling
        ptCentroid = mean(ptCloudLocation, 1);  
        ptMaxDist = max(vecnorm(ptCloudLocation - ptCentroid, 2, 2));  
        ptNormalizedLocations = (ptCloudLocation - ptCentroid) / ptMaxDist;  
        
        % Create point cloud objects for registration
        pcCurrent = pointCloud(ptNormalizedLocations);
        pcFaroRef = pointCloud(faroNormalizedLocations);
        
        % Perform bidirectional ICP registration to find best alignment
        [tform1, movingReg1, rmse1] = pcregistericp(pcCurrent, pcFaroRef, 'MaxIterations', 100);
        [tform2, movingReg2, rmse2] = pcregistericp(pcFaroRef, pcCurrent, 'MaxIterations', 100);
        
        % Select best alignment (lower RMSE)
        if rmse1 <= rmse2
            % Use first registration result
            alignedLocation = movingReg1.Location;
            usedForwardTransform = true;
        else
            % Manual inversion of affine3d transform
            T = tform2.T;  % Get 4x4 transformation matrix
            Tinv = eye(4);
            Tinv(1:3,1:3) = inv(T(1:3,1:3));  % Invert rotation
            Tinv(1:3,4) = -Tinv(1:3,1:3)*T(1:3,4);  % Invert translation
            invTform = affine3d(Tinv);
            alignedLocation = pctransform(pcCurrent, invTform).Location;
            usedForwardTransform = false;
        end
        
        % Denormalize using FARO reference parameters
        ptCloudAligned = alignedLocation * faroMaxDist + faroCentroid;
        ptScaledCloud = pointCloud(ptCloudAligned);
        
        % Save results if enabled
        if SAVE_SCALED
            ptFolder = fullfile(scaledPointDir, subFolders(i).name);
            if ~exist(ptFolder, "dir")
                mkdir(ptFolder)
            end
            ptFilePath = fullfile(ptFolder, plyFileName);
            pcwrite(ptScaledCloud, ptFilePath);
        end

        % Compute Chamfer Distance
        if ~isempty(faroNormalizedLocations)
            % Save normalized point pairs
            ptFolder = fullfile(normalizedPointDir, subFolders(i).name);
            if ~exist(ptFolder, "dir")
                mkdir(ptFolder)
            end
            
            % alignedLocation is the transformed point cloud in FARO
            % coordinate system
            pcwrite(pointCloud(alignedLocation), fullfile(ptFolder, plyFileName));
            pcwrite(pcFaroRef, fullfile(ptFolder, ['faro_' plyFileName]));
            cd = chamfer_distance(alignedLocation, faroNormalizedLocations, cd_mode);

        else
            cd = NaN;
        end
        cdTable{fileIdx + 1, i + 1} = cd; % Store in table
        
        % Visualize
        translatedLocations = alignedLocation;
        translatedLocations(:, 2) = translatedLocations(:, 2) + i * spacing;
        color = colors(i+1, :);
        coloredPtCloud = pointCloud(translatedLocations, 'Color', repmat(color, ptCloud.Count, 1));
        pcshow(coloredPtCloud, 'MarkerSize', 10);
        
        % Display CD
        textPos = mean(translatedLocations, 1);
        textPos(3) = textPos(3) + 1;
        text(textPos(1), textPos(2), textPos(3), sprintf('CD: %.4f', cd), ...
            'Color', 'w', 'FontSize', 14, 'FontWeight', 'bold', ...
            'BackgroundColor', 'k', 'EdgeColor', 'w', 'Margin', 2);

        legendInfo{i+1} = strrep(subFolders(i).name, '_', '\_');
    end
    
    legend(legendInfo, 'Location', 'best', 'TextColor', 'w', 'FontSize', 10);
    ax = gca;
    ax.XColor = 'w'; ax.YColor = 'w'; ax.ZColor = 'w'; ax.Color = 'k';
    ax.GridColor = 'w'; ax.FontSize = 12; ax.FontWeight = 'bold';
    xlabel('X', 'Color', 'w'); ylabel('Y', 'Color', 'w'); zlabel('Z', 'Color', 'w');

    % Save figure and videos
    if FIG
        saveas(gcf, fullfile(videoDir, name));
    end
    
    if SCREENSHOT
        view([90, 0]);
        saveas(gcf, fullfile(videoDir, [name '_upfront.png']));
        view([90, 90]);
        saveas(gcf, fullfile(videoDir, [name '_top.png']));
    end

    if VIDEO
        outputVideoFile = fullfile(videoDir, sprintf('%s_360_degree_video.mp4', name));
        videoWriter = VideoWriter(outputVideoFile, "MPEG-4");
        videoWriter.FrameRate = 30;
        open(videoWriter);
        
        for az = 1:100
            view(3*az, 30);
            drawnow;
            writeVideo(videoWriter, getframe(fig));
        end
    
        close(videoWriter);
        fprintf('360-degree video for %s saved successfully.\n', plyFileName);
    end

    close(fig);
end

% Save CD Table as CSV
if ~exist(csvFilePath, 'file')
    % Write new file with headers
    writecell(cdTable, csvFilePath);
    disp(['Chamfer Distance table saved at: ' csvFilePath]);
else
    % Append only data (excluding header row)
    writecell(cdTable, csvFilePath, 'WriteMode', 'append');
    disp(['Chamfer Distance table appended to: ' csvFilePath]);
end

if ~exist(metaFilePath, 'file')
    writecell(metaTable, metaFilePath);
    disp(['Metadata table saved at: ' metaFilePath]);
end
